(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[51],{4790:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/codex/[slug]",function(){return t(5106)}])},5106:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return k}});var o=t(5893),s=t(4741),a=t.n(s),i=t(1163),r=t(7294),l=t(5364),d=t(6681),c=t(240),u=t(6014);class m extends r.Component{getSnapshotBeforeUpdate(e){let n=this.props.childRef.current;if(n&&e.isPresent&&!this.props.isPresent){let e=this.props.sizeRef.current;e.height=n.offsetHeight||0,e.width=n.offsetWidth||0,e.top=n.offsetTop,e.left=n.offsetLeft}return null}componentDidUpdate(){}render(){return this.props.children}}function p({children:e,isPresent:n}){let t=(0,r.useId)(),s=(0,r.useRef)(null),a=(0,r.useRef)({width:0,height:0,top:0,left:0}),{nonce:i}=(0,r.useContext)(u._);return(0,r.useInsertionEffect)(()=>{let{width:e,height:o,top:r,left:l}=a.current;if(n||!s.current||!e||!o)return;s.current.dataset.motionPopId=t;let d=document.createElement("style");return i&&(d.nonce=i),document.head.appendChild(d),d.sheet&&d.sheet.insertRule(`
          [data-motion-pop-id="${t}"] {
            position: absolute !important;
            width: ${e}px !important;
            height: ${o}px !important;
            top: ${r}px !important;
            left: ${l}px !important;
          }
        `),()=>{document.head.removeChild(d)}},[n]),(0,o.jsx)(m,{isPresent:n,childRef:s,sizeRef:a,children:r.cloneElement(e,{ref:s})})}let h=({children:e,initial:n,isPresent:t,onExitComplete:s,custom:a,presenceAffectsLayout:i,mode:l})=>{let u=(0,d.h)(y),m=(0,r.useId)(),h=(0,r.useCallback)(e=>{for(let n of(u.set(e,!0),u.values()))if(!n)return;s&&s()},[u,s]),f=(0,r.useMemo)(()=>({id:m,initial:n,isPresent:t,custom:a,onExitComplete:h,register:e=>(u.set(e,!1),()=>u.delete(e))}),i?[Math.random(),h]:[t,h]);return(0,r.useMemo)(()=>{u.forEach((e,n)=>u.set(n,!1))},[t]),r.useEffect(()=>{t||u.size||!s||s()},[t]),"popLayout"===l&&(e=(0,o.jsx)(p,{isPresent:t,children:e})),(0,o.jsx)(c.O.Provider,{value:f,children:e})};function y(){return new Map}var f=t(5947);let g=e=>e.key||"";function w(e){let n=[];return r.Children.forEach(e,e=>{(0,r.isValidElement)(e)&&n.push(e)}),n}var v=t(8868);let x=({children:e,custom:n,initial:t=!0,onExitComplete:s,presenceAffectsLayout:a=!0,mode:i="sync",propagate:c=!1})=>{let[u,m]=(0,f.oO)(c),p=(0,r.useMemo)(()=>w(e),[e]),y=c&&!u?[]:p.map(g),x=(0,r.useRef)(!0),b=(0,r.useRef)(p),D=(0,d.h)(()=>new Map),[k,N]=(0,r.useState)(p),[C,E]=(0,r.useState)(p);(0,v.L)(()=>{x.current=!1,b.current=p;for(let e=0;e<C.length;e++){let n=g(C[e]);y.includes(n)?D.delete(n):!0!==D.get(n)&&D.set(n,!1)}},[C,y.length,y.join("-")]);let z=[];if(p!==k){let e=[...p];for(let n=0;n<C.length;n++){let t=C[n],o=g(t);y.includes(o)||(e.splice(n,0,t),z.push(t))}"wait"===i&&z.length&&(e=z),E(w(e)),N(p);return}let{forceRender:j}=(0,r.useContext)(l.p);return(0,o.jsx)(o.Fragment,{children:C.map(e=>{let r=g(e),l=(!c||!!u)&&(p===C||y.includes(r));return(0,o.jsx)(h,{isPresent:l,initial:(!x.current||!!t)&&void 0,custom:l?void 0:n,presenceAffectsLayout:a,mode:i,onExitComplete:l?void 0:()=>{if(!D.has(r))return;D.set(r,!0);let e=!0;D.forEach(n=>{n||(e=!1)}),e&&(null==j||j(),E(b.current),c&&(null==m||m()),s&&s())},children:e},r)})})};var b=t(607),D={"react-memo":{title:"React.memo",summary:"Prevents unnecessary re-renders of functional components by memoizing the result unless props change.",why:"React.memo is useful when a component renders the same output given the same props. It uses shallow comparison to detect prop changes. This is effective for performance-critical components that re-render often unnecessarily.\n\nUse cases include UI controls, status indicators, or list items receiving stable props.",example:"// ✅ Good\nconst MemoizedBtn = React.memo(function Button({ onClick, label }) {\n  return <button onClick={onClick}>{label}</button>;\n});\n\n// \uD83D\uDED1 Bad\nconst Timer = React.memo(({ time }) => <p>{time}</p>); // Renders anyway because props change every tick.",whenNot:"Don't use React.memo if:\n- The component is already very lightweight.\n- Props change on every render (e.g., timestamps).\n- The shallow compare doesn't offer benefits."},"node-event-loop":{title:"Node.js Event Loop Awareness",summary:"Understanding how the event loop works allows you to write more efficient asynchronous code.",why:"The event loop is central to Node.js. Avoid blocking it with CPU-heavy tasks or synchronous operations, or performance will degrade.\n\nUse async functions, avoid large sync loops, and offload heavy processing to worker threads.",example:"// ✅ Good\nsetTimeout(() => doAsyncWork(), 0);\n\n// \uD83D\uDED1 Bad\nwhile (true) { doWork(); } // Blocks loop",whenNot:"You may not need to optimize for the event loop if your app is primarily I/O-bound with minimal CPU work."},"js-memory-leaks":{title:"Avoid JavaScript Memory Leaks",summary:"Leaks happen when memory is retained unnecessarily. Clean up references, listeners, and timers.",why:"Memory leaks accumulate over time and degrade performance. Common causes include unremoved event listeners and global references.\n\nUse tools like Chrome DevTools, weak references, and be mindful of closures.",example:"// ✅ Good\ncomponentWillUnmount() {\n  window.removeEventListener('resize', this.handler);\n}\n\n// \uD83D\uDED1 Bad\nconst retained = document.getElementById('large'); // Stays forever",whenNot:"This applies universally. There is no safe time to ignore memory management in long-lived applications."},"api-pagination":{title:"API Pagination",summary:"Never return unbounded data. Always paginate large results from your API.",why:"Unbounded queries cause huge payloads, long load times, and excessive memory use. Pagination improves responsiveness and scales APIs.\n\nUse cursor-based or offset-based pagination depending on your use case.",example:"// ✅ Good\nGET /users?page=3&limit=50\n\n// \uD83D\uDED1 Bad\nGET /users // returns 10,000 records",whenNot:"Pagination can be avoided only when the dataset is guaranteed to be tiny and infrequently accessed."},"api-rate-limiting":{title:"API Rate Limiting",summary:"Limit requests to prevent abuse and protect server resources.",why:"Rate limiting mitigates DDoS, protects your infra, and ensures fair access. You can limit by IP, user ID, or token.\n\nUse libraries like express-rate-limit or middleware at the API Gateway level.",example:"// ✅ Good\nrateLimit({ windowMs: 15 * 60 * 1000, max: 100 });\n\n// \uD83D\uDED1 Bad\n// No limit. Bot sends 10,000 requests in seconds.",whenNot:"Internal APIs with tightly controlled access might not need rate limiting, but public-facing ones always should."},"code-splitting":{title:"Code Splitting (Dynamic Imports)",summary:"Split bundles to reduce initial load time.",why:"Large bundles slow down the time-to-interactive for users. Splitting non-critical parts of your app into separate chunks allows the browser to load what's necessary first.\n\nNext.js supports this natively via dynamic import().",example:"// ✅ Good\nconst HeavyComponent = dynamic(() => import('../HeavyComponent'));\n\n// \uD83D\uDED1 Bad\nimport HeavyComponent from '../HeavyComponent'; // always loads it up front",whenNot:"Avoid dynamic imports for small, frequently used components, as the overhead may outweigh the benefits."},"useMemo-useCallback":{title:"useMemo and useCallback",summary:"Memoize functions and values to avoid unnecessary re-creation.",why:"These hooks help avoid unnecessary computation or function identity changes that could trigger re-renders.\n\nThey're especially useful when passing props to memoized components.",example:"// ✅ Good\nconst memoizedFn = useCallback(() => doSomething(), []);\n\n// \uD83D\uDED1 Bad\nconst fn = () => doSomething(); // causes re-render every time",whenNot:"Avoid overusing these hooks. Only memoize if there’s a measurable performance impact."},"image-optimization":{title:"Image Optimization",summary:"Use Next.js <Image> component for optimal performance.",why:"Large images significantly slow down page load. Next.js' <Image> supports lazy loading, compression, and resizing.\n\nAlways provide width and height to reduce layout shifts.",example:'// ✅ Good\n<Image src="/hero.jpg" width={500} height={300} alt="Hero" />\n\n// \uD83D\uDED1 Bad\n<img src="/hero.jpg" /> // No optimization',whenNot:"Avoid it for icons or tiny assets where optimization overhead may not be worth it."},"lazy-loading":{title:"Lazy Loading Components",summary:"Load components only when needed to reduce initial bundle size.",why:"Lazy loading delays loading non-critical parts of the UI until they are needed, improving initial load times and reducing memory use.\n\nUse React.lazy or Next.js dynamic imports with suspense.",example:"// ✅ Good\nconst LazyComp = React.lazy(() => import('./LazyComp'));\n\n// \uD83D\uDED1 Bad\nimport LazyComp from './LazyComp'; // loads upfront",whenNot:"Do not lazy load components that are visible immediately, as it may cause layout shifts or flickers."},"prefetching-data":{title:"Prefetching Data",summary:"Load data in advance to improve perceived performance.",why:"Fetching data before it is strictly needed (e.g., on hover or route prefetch) results in faster transitions and better UX.\n\nNext.js supports route prefetching natively.",example:'// ✅ Good\n<Link href="/details" prefetch={true}>Details</Link>\n\n// \uD83D\uDED1 Bad\nNo prefetch, data loads only after navigation causing delays.',whenNot:"Avoid prefetching huge datasets or when network bandwidth is constrained."},"debounce-throttle":{title:"Debounce and Throttle Events",summary:"Limit how often expensive functions run in response to frequent events.",why:"Events like scroll, resize, or input can fire many times per second. Debouncing or throttling reduces computation overhead and prevents UI jank.",example:"// ✅ Good\nconst debouncedSearch = debounce(() => search(query), 300);\n\n// \uD83D\uDED1 Bad\nconst searchOnInput = () => search(query); // triggers on every keystroke",whenNot:"For infrequent or user-critical immediate responses, debounce may degrade UX."},"web-worker-usage":{title:"Use Web Workers for Heavy Computations",summary:"Offload CPU-intensive tasks to background threads.",why:"Heavy computations block the main thread causing UI freezes. Web Workers run in parallel and keep UI responsive.",example:"// ✅ Good\nconst worker = new Worker('heavyTask.js');\n\n// \uD83D\uDED1 Bad\nfunction heavyTask() {\n  while(true) {} // freezes UI",whenNot:"Not needed for lightweight or infrequent tasks where thread overhead is unjustified."},"ssr-caching":{title:"SSR Caching Strategies",summary:"Cache server-side rendered pages or data to speed up responses.",why:"Caching reduces server load and decreases latency by avoiding repeated expensive renders or data fetches.",example:"// ✅ Good\ngetStaticProps with revalidate: 60;\n\n// \uD83D\uDED1 Bad\nNo caching, every request hits the server anew",whenNot:"Avoid caching for highly dynamic data requiring real-time accuracy."},"bundle-analyzing":{title:"Bundle Analyzing",summary:"Analyze and optimize JavaScript bundle size.",why:"Understanding bundle contents helps identify and remove bloat, improving load times.",example:"// ✅ Good\nUsing webpack-bundle-analyzer to inspect sizes.\n\n// \uD83D\uDED1 Bad\nBlindly importing large libs increases bundle size unnecessarily.",whenNot:"Regular analysis is beneficial; skipping it is heresy to optimization."},"critical-css":{title:"Critical CSS Extraction",summary:"Inline above-the-fold CSS to speed up first paint.",why:"Inlining critical CSS reduces render-blocking resources, improving perceived load speed.",example:"// ✅ Good\nUsing Next.js built-in CSS support or tools like Critical for extraction.\n\n// \uD83D\uDED1 Bad\nLoading full CSS asynchronously causing FOUC.",whenNot:"Complex CSS may be too large to inline efficiently."},"http2-multiplexing":{title:"HTTP/2 Multiplexing",summary:"Serve multiple assets over a single connection for faster loads.",why:"HTTP/2 allows simultaneous requests reducing load time and overhead compared to HTTP/1.1.",example:"// ✅ Good\nHosting assets on HTTP/2 enabled servers.\n\n// \uD83D\uDED1 Bad\nUsing HTTP/1.1 and multiple connections slows loading.",whenNot:"Legacy environments or unsupported servers negate benefits."}};function k(){let e=(0,i.useRouter)(),{slug:n}=e.query,t=n&&D[n],s=Array.isArray(n)?n[0]:null!=n?n:"";return t?t?(0,o.jsx)("main",{"data-view-transition":"true",className:"min-h-screen bg-black text-red-200 p-8 ".concat(a().className),style:{perspective:"1500px"},children:(0,o.jsx)(x,{mode:"wait",children:(0,o.jsxs)(b.E.div,{initial:{opacity:0,scale:.92,y:30},animate:{opacity:1,scale:1,y:0},exit:{opacity:0,scale:.92,y:-30},transition:{duration:.35,ease:"easeInOut"},className:"max-w-4xl mx-auto border border-red-700 p-8 rounded-2xl bg-gray-950 shadow-lg",children:[(0,o.jsx)("h1",{className:"text-3xl text-red-400 mb-4 font-bold",children:t.title}),(0,o.jsx)("p",{className:"text-sm mb-4 text-gray-300 italic",children:t.summary}),(0,o.jsxs)("section",{className:"mb-6",children:[(0,o.jsx)("h2",{className:"text-xl text-red-500 underline underline-offset-4 mb-2",children:"\uD83E\uDDE0 Why Use It"}),(0,o.jsx)("p",{className:"text-gray-300 whitespace-pre-line",children:t.why})]}),(0,o.jsxs)("section",{className:"mb-6",children:[(0,o.jsx)("h2",{className:"text-xl text-red-500 underline underline-offset-4 mb-2",children:"✅ Good / Bad Example"}),(0,o.jsx)("pre",{className:"bg-gray-800 p-4 rounded text-sm overflow-x-auto text-green-200",children:t.example})]}),(0,o.jsxs)("section",{children:[(0,o.jsx)("h2",{className:"text-xl text-red-500 underline underline-offset-4 mb-2",children:"⚠️ When Not to Use"}),(0,o.jsx)("p",{className:"text-gray-300 whitespace-pre-line",children:t.whenNot})]}),(0,o.jsx)("div",{className:"mt-10 text-center",children:(0,o.jsx)("a",{href:"/",onClick:n=>{n.preventDefault(),"startViewTransition"in document?document.startViewTransition(()=>{e.push("/")}):e.push("/")},className:"text-red-300 hover:text-white underline cursor-pointer","aria-label":"Return to Codex",children:"⬅ Return to Codex"})})]},s)})}):(0,o.jsx)("p",{className:"text-white p-10 font-mono",children:"Loading sacred scroll..."}):(0,o.jsx)("p",{className:"text-white p-10 font-mono",children:"Sacred scroll not found. Please return to the Codex."})}},4741:function(e){e.exports={style:{fontFamily:"'__Share_Tech_Mono_439932', '__Share_Tech_Mono_Fallback_439932'",fontWeight:400,fontStyle:"normal"},className:"__className_439932"}},1163:function(e,n,t){e.exports=t(3035)}},function(e){e.O(0,[607,888,774,179],function(){return e(e.s=4790)}),_N_E=e.O()}]);